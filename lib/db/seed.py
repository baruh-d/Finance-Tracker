#!/usr/bin/env python3

from models import User, Transaction, Category
from sqlalchemy import create_engine
from sqlalchemy.orm import Session, sessionmaker
import random
from faker import Faker
from sqlalchemy.exc import IntegrityError
from datetime import datetime

fake = Faker()
# initialize the seed value to ensure random data generated by Faker remains consistent across multiple runs
# by initializing to zero. This will generate a new set of "random" values each time you run the script.
Faker.seed(0)

# Connect to the database
engine = create_engine('sqlite:///finance_tracker.db', echo=True)
Session = sessionmaker(bind=engine)

# def reset_database():
#     """Delete all data from all tables in the database."""
#     db_session = Session()
#     try:
#         # Deleting all records from tables in reverse order to avoid foreign key constraints
#         db_session.query(Transaction).delete()
#         db_session.query(User).delete()
#         db_session.query(Category).delete()
#         db_session.commit()
#     except Exception as e:
#         db_session.rollback()
#         print(f"Error occurred while resetting the database: {e}")
#     finally:
#         db_session.close()

def generate_data(n_users, num_transactions):
    """Populate the database with fake data."""
    db_session = Session()
    # calculating based on start and end dates for randomly generated dates
    start_date = fake.date_between(start_date='-4y', end_date='today')
    end_date = datetime.now()


    # Generating user data with unique email addresses
    users = []
    for _ in range(n_users):
        user = None
        while user is None:
            email = fake.email()
            existing_user = db_session.query(User).filter_by(email=email).first()
            if not existing_user:
                user = User(name=fake.name(), email=email)
                # Set password for each user
                User.set_password(user, fake.password())  # Ensure password is set
                users.append(user)
    # Attempting to save the generated users
    try:
        db_session.bulk_save_objects(users)
        db_session.commit()
    except IntegrityError as e:
        db_session.rollback()
        print(f"Error: {e}")


    # Generating categories
    categories = [
        Category(label="Groceries"),
        Category(label="Utilities"),
        Category(label="Entertainment"),
        Category(label="Transportation"),
        Category(label="Healthcare"),
        Category(label="Education"),
        Category(label="Shopping"),
    ]
    db_session.bulk_save_objects(categories)
    # Commit changes
    db_session.commit()
    
    # Get all category IDs
    category_ids = [category.id for category in categories]


    # Generating transaction data using associated classes/methods
    # db_session.query(Transaction).delete()

    users = db_session.query(User).all()


    for user in users:
        transactions_data = []
        num_transactions = random.randint(5, 20)
        for _ in range(num_transactions):
            amount = random.randint(1, 999999)
            transaction_type = random.choice(['debit', 'credit'])
            category_id = random.choice(category_ids)
            random_date = fake.date_time_between(start_date=start_date, end_date=end_date)
            transaction_data = Transaction(
                user_id=user.id,
                category_id=category_id,
                description=fake.text(),
                amount=amount,
                transaction_type=transaction_type,
                date=random_date,
            )
            transactions_data.append(transaction_data)

        db_session.bulk_save_objects(transactions_data)
        db_session.commit()

        # db_session.close()
def reset_categories():
    """Delete all existing categories and repopulate with default categories."""
    db_session = Session()
    try:
        # Delete all existing categories
        db_session.query(Category).delete()
        db_session.commit()
    except Exception as e:
        db_session.rollback()
        print(f"Error occurred while resetting categories: {e}")
    finally:
        db_session.close()

def populate(n_users=15, num_transactions=100):
    generate_data(n_users, num_transactions)


if __name__ == "__main__":
    populate()
